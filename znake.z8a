; /////////////////////////////////////////////////////////////////////////////

; Znake (ZX Spectrum 48K)

; Copyright (C) 2016, Chris Wyatt

; All rights reserved

; Distributed under the Apache 2 license (see LICENSE)

; /////////////////////////////////////////////////////////////////////////////

; Every time the snake changes direction, the turning point location will
; be appended to the following table, and snake_history_head_offset (end)
; offset) will be incremented by 1

; Once the tail has completed a turn, the snake_history_tail_offset (start)
; will be incremented by 1

; Both tables are purposefully 256 bytes, so that the offsets will wrap
; around to 0 whenever they exceed 255. Also the play field is 16 x 16 and
; theoretically the snake could turn at every location in the grid;
; however, this is rather unlikely.

; Data that does not lie within start and end offset will remain in the
; table; there is no need to null it

; Initially the tables contain the snake's tail and head (in that order)

; The high byte contains the X coordinate, and the low byte contains the Y
; coordinate

TBL_SNAKE_HISTORY: EQU 0xfd00

; Note: The food routine relies on the following tables being consecutive and
;       in a specific order:

TBL_SNAKE_HISTORY_CLEAN: EQU 0xfa00

; The following tables hold the top-left and bottom-right coordinates of each
; free square: i.e., each square that does not contain any snake. This is
; required to be able to pick the location of new food

; Due to the algorithm that calculates free squares, it is impossible for there
; to be more than 192 squares required. In reality, this would be even less due
; to the snake not being able to chop itself into small pieces, but I have no
; idea how to calculate the actual space required.

; The high bytes contain the X coordinates, and the low bytes contain the Y
; coordinates

TBL_FREE_SQUARES_TL_TABLE: EQU 0xfb00

TBL_FREE_SQUARES_BR_TABLE: EQU 0xfc00

org 0x8080

; Interrupt routine.

    ex af,af'
    exx

    ; Increment frame counter
    ld hl,23672
    inc (hl)

    exx
    ex af,af'

    ei
    reti

org 0x8100

graphics:

    ; blank (used to clear parts of the screen)
    db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

    ; snake head up
    db 0x00, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e

    ; snake head right
    db 0x00, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0x00

    ; snake head down
    db 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x00

    ; snake head left
    db 0x00, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00

    ; snake body up/down
    db 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e

    ; snake body left/right
    db 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00

    ; snake body up-right / left-down
    db 0x00, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7e

    ; snake body down-right / left-up
    db 0x7e, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00

    ; snake body down-left / right-up
    db 0x7e, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0x00

    ; snake body up-left / right-down
    db 0x00, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0x7e

    ; snake tail up
    db 0x00, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e

    ; snake tail right
    db 0x00, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0x00

    ; snake tail down
    db 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x00

    ; snake tail left
    db 0x00, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00

    ; food
    db 0x00, 0x18, 0x18, 0x66, 0x66, 0x18, 0x18, 0x00

    ; Border top
    db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00

    ; Border right
    db 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40

    ; Border bottom
    db 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

    ; Border left
    db 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02

    ; Border top-right
    db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x40

    ; Border bottom-right
    db 0x40, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

    ; Border bottom-left
    db 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

    ; Border top-left
    db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x02

; Starting offset for snake history
snake_history_tail_offset: db 0x00

; End offset for snake history
snake_history_head_offset: db 0x00

; The length of the clean snake history table (byte per item)
snake_history_clean_length: db 0x00

; The length of both free squares tables (byte per item)
free_squares_length: db 0x00

; Current direction of snake (bits: 0000UDLR)
snake_direction_current: db 0x00

; Snake direction queue (bits: UDLRUDLR)
; (low bits have higher priority)
snake_direction_queue: db 0x00

; The current location of the snake's food
current_food_location: db 0x00

; Bit 0: Food eaten
; Bits 1-7: Reserved
flags: db 0x00

previous_frame_count: db 0x00

; Calculating this from snake history would be too expensive
snake_length: db 0

; Stack pointer backup
sp_bak: defw 0x0000

random:

; Simple pseudo-random number generator.
; Steps a pointer through the ROM (held in seed), returning
; the contents of the byte at that location

; Modifies registers af and hl

; (Lifted from How to Write ZX Spectrum Games 1.0 by Jonathan Cauldwell)

    ld hl,(seed)

    ; Keep it within first 8k of ROM.
    and 31
    ld a,h
    ld h,a

    ld a,(hl)

    inc hl
    ld (seed),hl

    ret

seed: defw 0x0000

modulo:

    ; Modifies registers af and bc

    ; Return if divisor = 0
    ld a,c
    or a
    ret z

    ld a,b

modulo_sub:

    sub c

    jr nc,modulo_sub

    add a,c
    ret

draw_char:

; Takes column/row (bc) and pointer (hl) and draws a character to the display
; buffer

    ; Get the memory location of the first line of a character

    ; Calculate high byte of display location

    ; The high byte represents the display section and line number (which is
    ; added later on)

    ld a,e

    ; Discard all but bits 3 and 4. Taken in isolation, these are the offsets
    ; for the display section, specifically 0x00, 0x08 and 0x10
    and 0x18 ;

    ; The high byte for the first line of each character is either 0x40, 0x48
    ; or 0x50, depending on which section it recides in
    add a,0x40

    ld b,a

    ; Calculate low byte of display location

    ; The low byte represents row and column numbers

    ld a,e

    ; This calculates the row number grouped by display section, i.e.:
    ; row 0 = 0x00, row 1 = 0x20, row 7 = 0xE0, row 8 = 0x00, etc.
    rrca
    rrca
    rrca
    and 0xf0

    ; The first line of each column is offset by a byte
    add a,d

    ld d,b
    ld e,a

    ; A character has 8 lines
    ld b,8

draw_line:

; Draw a character line by line

    ld a,(hl)
    ld (de),a
    inc l

    ; The high byte is incremented to get the destination of the next line
    inc d

    djnz draw_line

    ret

check_quadrants:

    ld c,0x11

    ld a,e
    rlca
    rlca
    rlca
    rlca
    or e
    sub c
    ld b,a

check_quadrant:

    push de

    ; Set register d to the location of the top-left corner
    ld a,d
    add a,e
    ld d,a

    ; Set register e to the location of the bottom-right corner
    ld a,d
    add a,b
    ld e,a

    ld c,0xf0

    ld h,(TBL_SNAKE_HISTORY_CLEAN >> 8) & $FF

    ld a,(snake_history_clean_length)
    dec a
    ld l,a

    ; Load first turn or head location to register b
    ld b,(hl)

next_snake_section:

    dec l

    ; Load second turn or tail location to register a
    ld a,(hl)

    ; Check which end of the snake section has a higher X or Y value
    cp b
    jr c,check_no_overlap_pos

    ; TODO: Investigate turning pos and neg routines into a single macro

; Check no overlap (neg)

    ; Tail/turn 2 (B2) already in register a

    ; Minus top-left of square (A1)
    sub d

    ; If carry, A1x > B2x or A1y > B2y
    ; (A1y > B2y only detected in certain edge cases, which is why we check
    ;  if the Y nibble carries in the next check)
    jr c,no_overlap

    ; Check half carry
    and c ; 0xf0
    add a,d
    xor (hl)
    and c ; 0xf0
    jr nz,no_overlap

    ; Bottom-right of square (A2)
    ld a,e

    ; Minus tail/turn 1 (B1)
    sub b

    ; If carry, B1x > A2x or B1y > A2y
    ; (B1y > A2y only detected in certain edge cases, which is why we check
    ;  if the Y nibble carries in the next check)
    jr c,no_overlap

    ; Check half carry
    and c ; 0xf0
    add a,b
    xor e
    and c ; 0xf0
    jr nz,no_overlap

    jp overlap

check_no_overlap_pos:

    ; Tail/turn 2 (B2)
    ld a,b

    ; Minus top-left of square (A1)
    sub d

    ; If carry, A1x > B2x or A1y > B2y
    ; (A1y > B2y only detected in certain edge cases, which is why we check
    ;  if the Y nibble carries in the next check)
    jr c,no_overlap

    ; Check half carry
    and c ; 0xf0
    add a,d
    xor b
    and c ; 0xf0
    jr nz,no_overlap

    ; Bottom-right of square (A2)
    ld a,e

    ; Minus tail/turn 1 (B1)
    sub (hl)

    ; If carry, B1x > A2x or B1y > A2y
    ; (B1y > A2y only detected in certain edge cases, which is why we check
    ;  if the Y nibble carries in the next check)
    jr c,no_overlap

    ; Check half carry
    and c ; 0xf0
    add a,(hl)
    xor e
    and c ; 0xf0
    jr nz,no_overlap

overlap:

    ld c,0x11

    ; Cannot divide square (i.e. 1 pixel)
    ld a,e
    sub d
    jr z,next_quadrant

    ; Load the offset to the bottom-right of the top-left quadrant to register
    ; b
    add a,c ; 0x11
    rrca
    ld e,a
    sub c ; 0x11
    ld b,a

    ; Load the offset to the bottom-left quadrant to register e
    ld a,e
    and 0x0f
    ld e,a

    ; Check quadrants within this quadrant
    call check_quadrant

next_quadrant:

    ; Pop location of top-left quadrant and offset to bottom-left quadrant
    ; from the stack
    pop de

    ld a,e
    or a

    ; If top-left, return
    ret z

    jp pe,bottom_right

    cp 0x09
    jr c,bottom_left

    ; Top-right

    ld a,e
    rrca
    rrca
    rrca
    rrca
    or e
    sub c ; 0x11
    ld b,a

    ld e,0x00

    jp (iy) ; check_quadrant

no_overlap:

    ld b,(hl)

    ; Continue to next snake section if l != 0
    xor a
    xor l
    jp nz,next_snake_section

    ld c,0x11

    ; Otherwise, add this quadrant to the free squares tables

    ld a,(free_squares_length)
    ld l,a

    ; This is a bit flimsy, as it relies on the tables being next to each other
    ; in a specific order

    inc h
    ; h = TBL_FREE_SQUARES_TL_TABLE

    ld (hl),d

    inc h
    ; h = TBL_FREE_SQUARES_BR_TABLE

    ld (hl),e

    inc a
    ld (free_squares_length),a

    jp (ix) ; next_quadrant

bottom_left:

    rlca
    rlca
    rlca
    rlca
    or e
    ld e,a

    sub c ; 0x11
    ld b,a

    jp (iy) ; check_quadrant

bottom_right:

    sub c ; 0x11
    ld b,a

    ld a,e
    and 0xf0
    ld e,a

    jp (iy) ; check_quadrant

start:

    di

    ld (sp_bak),sp

    ld hl,0xfe00

    ; Load high byte of pointer table to interrupt vector register
    ld a,h
    ld i,a

    ; Load 257 interrupt routine pointers to memory
    ld de,0xfe01
    ld bc,256
    ld (hl),0x80
    ldir

    ; Initialise IM2 interrupt routine
    im 2
    ei

    ld ix,next_quadrant
    ld iy,check_quadrant

restart:

    ld sp,(sp_bak)

    ; Set border color to black
    xor a ; a = 0
    call $229B

    ; Clear screen
    ld hl,0x4000
    ld de,0x4001
    ld bc,0x17ff
    ld (hl),0
    ldir

draw_top_border:

    ld c,16

    ; Location of border top
    ld hl,0x8180

    ; Column/row
    ld de,0x0803

draw_top_border_next:

    push de
    push hl
    call draw_char
    pop hl
    pop de

    inc d
    dec c
    jr nz,draw_top_border_next

draw_right_border:

    ld c,16

    ; Location of border right
    ld hl,0x8188

    ; Column/row
    ld de,0x1804

draw_right_border_next:

    push de
    push hl
    call draw_char
    pop hl
    pop de

    inc e
    dec c
    jr nz,draw_right_border_next

draw_bottom_border:

    ld c,16

    ; Location of border top
    ld hl,0x8190

    ; Column/row
    ld de,0x0814

draw_bottom_border_next:

    push de
    push hl
    call draw_char
    pop hl
    pop de

    inc d
    dec c
    jr nz,draw_bottom_border_next

draw_left_border:

    ld c,16

    ; Location of border right
    ld hl,0x8198

    ; Column/row
    ld de,0x0704

draw_left_border_next:

    push de
    push hl
    call draw_char
    pop hl
    pop de

    inc e
    dec c
    jr nz,draw_left_border_next

    ; Location of border top-right
    ld hl,0x81a0

    ; Column/row
    ld de,0x1803

    call draw_char

    ; Location of border bottom-right
    ld hl,0x81a8

    ; Column/row
    ld de,0x1814

    call draw_char

    ; Location of border bottom-left
    ld hl,0x81b0

    ; Column/row
    ld de,0x0714

    call draw_char

    ; Location of border top-left
    ld hl,0x81b8

    ; Column/row
    ld de,0x0703

    call draw_char

    ; Initialise snake

    xor a ; a = 0x00
    ld (snake_history_tail_offset),a
    ld a,0x01
    ld (snake_history_head_offset),a
    ld a,0x02
    ld (snake_direction_current),a
    ld a,0x87
    ld (TBL_SNAKE_HISTORY),a
    ld a,0x67
    ld (TBL_SNAKE_HISTORY + 1),a

    ld a,3
    ld (snake_length),a

    ; Set food eaten flag
    ld hl,flags
    set 0,(hl)

    ; Initialise previous frame count
    ld a,(23672)
    ld (previous_frame_count),a

    ; Draw initial snake graphics

    ; Location of snake head left
    ld hl,0x8120

    ; Column/row
    ld de,0x0e0b ; 6 + 8, 7 + 4

    call draw_char

    ; Location of snake body left/right
    ld hl,0x8130

    ; Column/row
    ld de,0x0f0b ; 7 + 8, 7 + 4

    call draw_char

    ; Location of snake tail right
    ld hl,0x8160

    ; Column/row
    ld de,0x100b ; 8 + 8, 7 + 4

    call draw_char

next_game_loop:

    ; If food eaten flag is not set, jump
    ld a,(flags)
    bit 0,a
    jp z,initiate_input_loop

    ; Create a new snake history table, where the data starts at the beginning
    ; of the table: this means we can free up a register later, as we will not
    ; need a counter

    ld h,(TBL_SNAKE_HISTORY >> 8) & $FF
    ld a,(snake_history_tail_offset)
    ld l,a

    ; Initialise counter
    ld a,(snake_history_head_offset)
    sub l
    inc a
    ld b,a

    ld (snake_history_clean_length),a

    ld de,TBL_SNAKE_HISTORY_CLEAN

transfer_byte:

    ; Transfer from one table to another. LDIR is not used here, as we need to
    ; jump to the beginning at table boundaries.

    ld a,(hl)
    ld (de),a
    inc l
    inc e
    dec b
    jr nz,transfer_byte

    ; Initialise free squares table
    xor a ; a = 0
    ld (free_squares_length),a

; The following routine finds free space that is not occupied by the snake, and
; places new food in this free space. It divides the map into 4 quadrants
; (TR, BR, BL, TL); any quadrant that does not contain snake is added to the
; free squares tables; any quadrant that does contain snake is further divided
; into quadrants until all free space is mapped.

    ; d: location of top-left quadrant
    ; e: offset to bottom-left quadrant / width / height
    ld de,0x0008

    call check_quadrants

create_food:

    ; Pick a random free square

    ld a,(free_squares_length)

    ; Skip food generation if snake has filled the screen
    ; (TODO: End game with congratulatory message)
    or a
    jp z,initiate_input_loop

    ; Random number limit
    ld c,a

    call random
    ld b,a

    call modulo
    ld l,a

    ld h,(TBL_FREE_SQUARES_TL_TABLE >> 8) & $FF
    ld d,(hl)

    inc h ; TBL_FREE_SQUARES_BR_TABLE
    ld e,(hl)

    ; Pick a random position within the free square

    ; Load square width/height to register h
    ld a,e
    sub d
    ld h,a

    ; Random number limit
    and 0x0f
    ld c,a

    ; X-coordinate

    push hl
    call random
    pop hl

    ld b,a
    call modulo

    rlca
    rlca
    rlca
    rlca
    and 0xf0
    ld b,a

    ; Y-coordinate

    push hl
    call random
    pop hl

    push bc
    call modulo
    pop bc

    or b

    ; Add location of top-left of square, to get the actual food location
    add a,d

    ld (current_food_location),a
    ld e,a

    ; Location of food
    ld hl,0x8178

    ; Column/row
    rrca
    rrca
    rrca
    rrca
    and 0x0f
    add a,8
    ld d,a

    ld a,e
    and 0x0f
    add a,4
    ld e,a

    halt
    call draw_char

    ; Reset food eaten flag
    ld hl,flags
    res 0,(hl)

initiate_input_loop:

    ld a,(snake_direction_current)
    ld d,a

    ld a,(snake_direction_queue)
    ld e,a

; Check for diagonal input from Kempston joystick port
read_kempston_d:

    in a,(0x1f)

    ; up-right (bits 0 and 3)
    ld b,0x09
    cp b
    jr z,kempston_joy_up_right

    ; down-right (bits 0 and 2)
    ld b,0x05
    cp b
    jr z,kempston_joy_down_right

    ; down-left (bits 1 and 2)
    ld b,0x06
    cp b
    jr z,kempston_joy_down_left

    ; up-left (bits 1 and 3)
    ld b,0x0a
    cp b
    jr z,kempston_joy_up_left

    ; Horizontal/vertical logic relies on last queued direction(s)

    ; Get last direction(s)
    ld a,e
    or a
    jr z,direction_not_queued

    ; Otherwise, direction queued
    ld b,a
    jp read_kempston_hv

direction_not_queued:

    ld b,d

; Check for horizontal/vertical input from Kempston joystick port
read_kempston_hv:

    in a,(0x1f)

    bit 3,a ; up
    jr nz,kempston_joy_up
    bit 0,a ; right
    jr nz,kempston_joy_right
    bit 2,a ; down
    jr nz,kempston_joy_down
    bit 1,a ; left
    jr nz,kempston_joy_left

    ; If no bits are on, make sure that only one direction is queued;
    ; otherwise the snake may veer off in an unintended direction

    ld a,e

    ; If queue contains 1 direction, jump to next input loop
    or a
    jp po,next_input_loop

    ; Else, if queue is empty, jump to next input loop
    jp z,next_input_loop

    ; Otherwise only keep the highest priority direction
    ld a,e
    and 0x0f
    ld e,a

    jp next_input_loop

; The following bitmasks could also allow the opposite directions too, e.g.
; if the bitmask is left, it could also accept right. This would make the
; controls more sensitive at the expense of accidentally turning the snake
; in an unintentional direction. This also helps with the ZX Vega D-pad's
; tendency to lean in a diagonal direction, when the user intended a
; horizontal/vertical direction. We could consider allowing this to be user
; configurable.

kempston_joy_up_right:

    ; If current direction is left
    bit 1,d
    jr nz,queue_up_right

    ; If current direction is down
    bit 2,d
    jr nz,queue_right_up

    ; Else ignore
    jp next_input_loop

kempston_joy_down_right:

    ; If current direction is left
    bit 1,d
    jr nz,queue_down_right

    ; If current direction is up
    bit 3,d
    jr nz,queue_right_down

    ; Else ignore
    jp next_input_loop

kempston_joy_down_left:

    ; If current direction is right
    bit 0,d
    jr nz,queue_down_left

    ; If current direction is up
    bit 3,d
    jr nz,queue_left_down

    ; Else ignore
    jp next_input_loop

kempston_joy_up_left:

    ; If current direction is right
    bit 0,d
    jr nz,queue_up_left

    ; If current direction is down
    bit 2,d
    jr nz,queue_left_up

    ; Else ignore
    jp next_input_loop

queue_up_right:

    ld e,0x18

    jp next_input_loop

queue_right_up:

    ld e,0x81

    jp next_input_loop

queue_right_down:

    ld e,0x41

    jp next_input_loop

queue_down_right:

    ld e,0x14

    jp next_input_loop

queue_down_left:

    ld e,0x24

    jp next_input_loop

queue_left_down:

    ld e,0x42

    jp next_input_loop

queue_left_up:

    ld e,0x82

    jp next_input_loop

queue_up_left:

    ld e,0x28

    jp next_input_loop

kempston_joy_up:

    ; Direction requested, bitmask for left and right
    ld hl,0x0803

    jp kempston_joy_hv

kempston_joy_right:

    ; Direction requested, bitmask for up and down
    ld hl,0x010c

    jp kempston_joy_hv

kempston_joy_down:

    ; Direction requested, bitmask for left and right
    ld hl,0x0403

    jp kempston_joy_hv

kempston_joy_left:

    ; Direction requested, bitmask for up and down
    ld hl,0x020c

; Deal with queuing horizontal/vertical direction requests
kempston_joy_hv:

    ; Load last requested direction into accumulator
    ld a,b

    ; If 0 or 1 last requested directions, jump

    or a
    jp po,kempston_joy_hv_part_2
    jr z,kempston_joy_hv_part_2

    ; Otherwise, use the higher bits, as these contain the last requested
    ; direction

    rrca
    rrca
    rrca
    rrca
    and 0x0f

kempston_joy_hv_part_2:

    ; If last direction requested is not in bitmask, ignore
    and l
    jr z,next_input_loop

    ld a,e

    ; If queue contains 0 or 2 directions, replace
    or a
    jp pe,replace_direction_queue

    ; Otherwise append

    ld a,h
    rlca
    rlca
    rlca
    rlca
    and 0xf0
    or e
    ld e,a

    jp next_input_loop

replace_direction_queue:

    ld e,h

next_input_loop:

    ; If the current frame count is less than the previous frame count, plus
    ; frame_wait, then continue input loop

    ld hl,previous_frame_count
    ld a,(23672)
    sub (hl)

    ; Snake speed (higher = slower)
    sub 8

    jp c,read_kempston_d

    ; Otherwise, store the new frame count ...

    ld a,(23672)
    ld (previous_frame_count),a

    ; ... and update the current direction

    ; If direction not queued, jump
    ld a,e
    and 0x0f
    jr z,update_head_history

    ; Otherwise, update the current direction ...

    ld d,a

    ; ... and pop the new direction from the direction queue

    ld a,e
    rrca
    rrca
    rrca
    rrca
    and 0x0f
    ld e,a

update_head_history:

    ; We need to free up these registers now

    ld a,d
    ld (snake_direction_current),a

    ld a,e
    ld (snake_direction_queue),a

    ld h,(TBL_SNAKE_HISTORY >> 8) & $FF

    ; Move pointer to end of snake history
    ld a,(snake_history_head_offset)
    ld l,a

    ; Load current head location to register e
    ld e,(hl)

    ; Move pointer to turn (or tail) before head
    dec l

    ; Load current turn location to register b
    ld b,(hl)

    ; Move pointer back to head
    inc l

    ; Subtract turn location from head location

    ld a,e
    xor b
    cp 0x10
    jr c,head_moving_vertically

    ; Head moving horizontally

    ; Restore head location
    xor b

    and 0xf0
    ld c,a
    ld a,b
    and 0xf0
    sub c
    jr c,head_moving_right
    jp head_moving_left

head_moving_vertically:

    ; Restore head location
    xor b

    and 0x0f
    ld c,a
    ld a,b
    and 0x0f
    sub c
    jr c,head_moving_down

; Head moving up

    ; Load head location to register b
    ld b,e

    ; Depending on the current direction, the new head location may be placed
    ; to the right or to the left ...

    bit 0,d
    jp nz,head_turning_up_right

    bit 1,d
    jp nz,head_turning_up_left

    ; Low bit of graphics
    ld c,0x28

    ; Draw later
    push bc

    ; ... otherwise the head is still moving up

    ; Get head location again and shift it up
    dec b

    ; Low bit of graphics
    ld c,0x08

    ; Draw later
    push bc

    ; Update the existing head location in our table
    ld (hl),b

    jp check_food_eaten

head_moving_right:

    ; Load head location to register b
    ld b,e

    ; Depending on the current direction, the new head location may be placed
    ; to the top or to the bottom ...

    bit 2,d
    jp nz,head_turning_right_down

    bit 3,d
    jp nz,head_turning_right_up

    ; Low bit of graphics
    ld c,0x30

    ; Draw later
    push bc

    ; ... otherwise the head is still moving right

    ; Get head location again and shift it right
    ld a,b
    add a,0x10

    ; Update the existing head location in our table
    ld (hl),a

    ; Push new head location back to b register
    ld b,a

    ; Low bit of graphics
    ld c,0x10

    ; Draw later
    push bc

    jp check_food_eaten

head_moving_down:

    ; Load head location to register b
    ld b,e

    ; Depending on the current direction, the new head location may be placed
    ; to the right or to the left ...

    bit 0,d
    jp nz,head_turning_down_right

    bit 1,d
    jp nz,head_turning_down_left

    ; Low bit of graphics
    ld c,0x28

    ; Draw later
    push bc

    ; ... otherwise the head is still moving up

    ; Get head location again and shift it down
    inc b

    ; Low bit of graphics
    ld c,0x18

    ; Draw later
    push bc

    ; Update the existing head location in our table
    ld (hl),b

    jp check_food_eaten

head_moving_left:

    ; Load head location to register b
    ld b,e

    ; Depending on the current direction, the new head location may be placed
    ; to the top or to the bottom ...

    bit 2,d
    jp nz,head_turning_left_down

    bit 3,d
    jp nz,head_turning_left_up

    ; Low bit of graphics
    ld c,0x30

    ; Draw later
    push bc

    ; ... otherwise the head is still moving right

    ; Get head location again and shift it left
    ld a,b
    sub 0x10

    ; Update the existing head location in our table
    ld (hl),a

    ; Push new head location back to b register
    ld b,a

    ; Low bit of graphics
    ld c,0x20

    ; Draw later
    push bc

    jp check_food_eaten

head_turning_up_right:

    ; Low bit of graphics
    ld c,0x38

    ; Draw later
    push bc

    ; Get head location again and shift it right
    ld a,b
    add a,0x10

    ; Push new head location back to b register
    ld b,a

    ; Low bit of graphics
    ld c,0x10

    ; Draw later
    push bc

    ; Move pointer to new head location
    inc l

    ; Add new head location to our table
    ld (hl),a

    ld a,(snake_history_head_offset)
    inc a
    ld (snake_history_head_offset),a

    jp check_food_eaten

head_turning_right_up:

    ; Low bit of graphics
    ld c,0x48

    ; Draw later
    push bc

    ; Get head location again and shift it up
    dec b

    ; Low bit of graphics
    ld c,0x08

    ; Draw later
    push bc

    ; Move pointer to new head location
    inc l

    ; Add new head location to our table
    ld (hl),b

    ld a,(snake_history_head_offset)
    inc a
    ld (snake_history_head_offset),a

    jp check_food_eaten

head_turning_right_down:

    ; Low bit of graphics
    ld c,0x50

    ; Draw later
    push bc

    ; Get head location again and shift it down
    inc b

    ; Low bit of graphics
    ld c,0x18

    ; Draw later
    push bc

    ; Move pointer to new head location
    inc l

    ; Add new head location to our table
    ld (hl),b

    ; Because the snake has turned:
    ld a,(snake_history_head_offset)
    inc a
    ld (snake_history_head_offset),a

    jp check_food_eaten

head_turning_down_right:

    ; Low bit of graphics
    ld c,0x40

    ; Draw later
    push bc

    ; Get head location again and shift it right
    ld a,b
    add a,0x10

    ; Push new head location back to b register
    ld b,a

    ; Low bit of graphics
    ld c,0x10

    ; Draw later
    push bc

    ; Move pointer to new head location
    inc l

    ; Add new head location to our table
    ld (hl),a

    ld a,(snake_history_head_offset)
    inc a
    ld (snake_history_head_offset),a

    jp check_food_eaten

head_turning_down_left:

    ; Low bit of graphics
    ld c,0x48

    ; Draw later
    push bc

    ; Get head location again and shift it left
    ld a,b
    sub 0x10

    ; Push new head location back to b register
    ld b,a

    ; Low bit of graphics
    ld c,0x20

    ; Draw later
    push bc

    ; Move pointer to new head location
    inc l

    ; Add new head location to our table
    ld (hl),a

    ld a,(snake_history_head_offset)
    inc a
    ld (snake_history_head_offset),a

    jp check_food_eaten

head_turning_left_down:

    ; Low bit of graphics
    ld c,0x38

    ; Draw later
    push bc

    ; Get head location again and shift it down
    inc b

    ; Low bit of graphics
    ld c,0x18

    ; Draw later
    push bc

    ; Move pointer to new head location
    inc l

    ; Add new head location to our table
    ld (hl),b

    ld a,(snake_history_head_offset)
    inc a
    ld (snake_history_head_offset),a

    jp check_food_eaten

head_turning_left_up:

    ; Low bit of graphics
    ld c,0x40

    ; Draw later
    push bc

    ; Get head location again and shift it up
    dec b

    ; Low bit of graphics
    ld c,0x08

    ; Draw later
    push bc

    ; Move pointer to new head location
    inc l

    ; Set new head location up 1 from previous head
    ld (hl),b

    ; Because the snake has turned:
    ld a,(snake_history_head_offset)
    inc a
    ld (snake_history_head_offset),a

    jp check_food_eaten

head_turning_up_left:

    ; Low bit of graphics
    ld c,0x50

    ; Draw later
    push bc

    ; Get head location again and shift it left
    ld a,b
    sub 0x10

    ; Push new head location back to b register
    ld b,a

    ; Low bit of graphics
    ld c,0x20

    ; Draw later
    push bc

    ; Move pointer to new head location
    inc l

    ; Add new head location to our table
    ld (hl),a

    ld a,(snake_history_head_offset)
    inc a
    ld (snake_history_head_offset),a

check_food_eaten:

    ld a,(current_food_location)
    cp (hl)

    ; If location of head does not equal current food location, continue to
    ; update tail history routine
    jr nz,update_tail_history

    ; Otherwise, set food eaten flag ...
    ld hl,flags
    set 0,(hl)

    ; Record snake length increase
    ld hl,snake_length
    inc (hl)

    ; Skip tail update (i.e. grow snake)
    jp collision_detection

update_tail_history:

    ; Move pointer to start of snake history
    ld h,(TBL_SNAKE_HISTORY >> 8) & $FF
    ld a,(snake_history_tail_offset)
    ld l,a

    ; Load current tail location to register b
    ld d,(hl)

    ; Low bit of graphics (blank)
    ld e,0x00

    ; Draw later
    push de

    ; Move pointer to turn (or head) before tail
    inc l

    ; Load current turn location to register e
    ld e,(hl)

    ld a,e

    xor d
    cp 0x10
    jr c,tail_moving_vertically

    ; Tail moving horizontally

    ; Restore current turn location
    xor d

    and 0xf0
    ld c,a
    ld a,d
    and 0xf0
    sub c
    jr c,tail_moving_right
    jp tail_moving_left

tail_moving_vertically:

    ; Restore current turn location
    xor d

    and 0x0f
    ld c,a
    ld a,d
    and 0x0f
    sub c
    jr c,tail_moving_down

; Tail moving up

    cp 0x01
    jr z,chop_off_tail

    ; Shift location up
    dec d

    ; Low bit of graphics
    ld e,0x68

    ; Draw later
    push de

    ; Move pointer back to tail
    dec l

    ; And update the existing tail location in our table
    ld (hl),d

    jp collision_detection

tail_moving_right:

    cp 0xf0
    jr z,chop_off_tail

    ; Get tail location again and shift it right
    ld a,d
    add a,0x10
    ld d,a

    ; Low bit of graphics
    ld e,0x70

    ; Draw later
    push de

    ; Otherwise, move pointer back to tail
    dec l

    ; And update the existing tail location in our table
    ld (hl),d

    jp collision_detection

tail_moving_left:

    cp 0x10
    jr z,chop_off_tail

    ; Get tail location again and shift it left
    ld a,d
    sub 0x10
    ld d,a

    ; Low bit of graphics
    ld e,0x60

    ; Draw later
    push de

    ; Otherwise, move pointer back to tail
    dec l

    ; And update the existing tail location in our table
    ld (hl),d

    jp collision_detection

tail_moving_down:

    cp 0xff
    jr z,chop_off_tail

    ; Shift location down
    inc d

    ; Low bit of graphics
    ld e,0x58

    ; Draw later
    push de

    ; Otherwise, move pointer back to tail
    dec l

    ; And update the existing tail location in our table
    ld (hl),d

    jp collision_detection

chop_off_tail:

    ; Remove the reference to the old tail, and let the next turn in the
    ; snake's body be the new tail
    ld a,(snake_history_tail_offset)
    inc a
    ld (snake_history_tail_offset),a

    ; Load new tail location to register d
    ld d,e

    ; Move pointer to the turn after the new tail
    inc l

    ; Load current turn location to register e
    ld e,(hl)

    ld a,e

    xor d
    cp 16
    jr c,new_tail_moving_vertically

    ; New tail moving horizontally

    ; Restore current turn location
    xor d

    and 0xf0
    ld e,a
    ld a,d
    and 0xf0
    sub e
    jr c,new_tail_moving_right
    jp new_tail_moving_left

new_tail_moving_vertically:

    ; Restore current turn location
    xor d

    and 0x0f
    ld e,a
    ld a,d
    and 0x0f
    sub e
    jr c,new_tail_moving_down

; New tail moving up

    ; Low bit of graphics
    ld e,0x68

    ; Draw later
    push de

    jp collision_detection

new_tail_moving_right:

    ; Low bit of graphics
    ld e,0x70

    ; Draw later
    push de

    jp collision_detection

new_tail_moving_down:

    ; Low bit of graphics
    ld e,0x58

    ; Draw later
    push de

    jp collision_detection

new_tail_moving_left:

    ; Low bit of graphics
    ld e,0x60

    ; Draw later
    push de

collision_detection:

    ld h,(TBL_SNAKE_HISTORY >> 8) & $FF

    ld a,(snake_history_tail_offset)
    ld b,a

    ld a,(snake_history_head_offset)
    ld l,a

    ; Initialise counter
    sub b
    ld b,a

    ; Load current snake direction to register e
    ld a,(snake_direction_current)
    ld e,a

    ; Load head location to register c (A)
    ld a,(hl)
    ld c,a

    ; Load neck location to register d (B1)

    bit 0,e
    jr nz,head_right_of_neck
    bit 1,e
    jr nz,head_left_of_neck
    bit 2,e
    jr nz,head_below_neck

; Head above neck

    inc a

    jp check_border_collision_vertical

head_below_neck:

    dec a

    jp check_border_collision_vertical

head_left_of_neck:

    add a,0x10

    jp check_border_collision_horizontal

head_right_of_neck:

    sub 0x10

check_border_collision_horizontal:

    ld d,a

    jp c,restart
    jp collision_detection_next_snake_section

check_border_collision_vertical:

    ld d,a

    xor c
    and 0xf0
    jp nz,restart

collision_detection_next_snake_section:

    dec l

    ; Load second turn or tail location to register e (B2)
    ld a,(hl)
    ld e,a

    cp d
    jr nc,second_turn_higher

    ld e,d
    ld d,a

second_turn_higher:

    ld a,c
    cp d

    ; If carry, B1x > Ax or B1y > Ay
    ; (B1y > Ay only detected in certain edge cases, which is why we
    ;  isolate the Y nibble in the next check)
    jr c,no_collision

    ld a,d
    and 0x0f
    ld d,a
    ld a,c
    and 0x0f
    sub d

    ; If carry, B1y > Ay
    jr c,no_collision

    ld a,e
    cp c

    ; If carry, Ax > B2x or Ay > B2y
    ; (Ax > B2y only detected in certain edge cases, which is why we
    ;  isolate the Y nibble in the next check)
    jr c,no_collision

    ; Isolate Y nibble
    ld a,c
    and 0x0f
    ld d,a
    ld a,e
    and 0x0f
    sub d

    ; If carry, Ay > B2y
    jr c,no_collision

    ; Collision
    jp restart

no_collision:

    ld d,(hl)

    djnz collision_detection_next_snake_section

update_graphics_init:

    ; If food eaten flag is not set, loop 4 times to update grid locations:
    ; new head, existing head, new tail, existing tail

    ld hl,flags
    bit 0,(hl)

    halt

    jr z,draw_tail

    ; Otherwise, loop 2 times to update grid locations: new head, existing head

    ld c,3

    jp update_graphics

draw_tail:

    ld c,5

update_graphics:

    dec c
    jp z,next_game_loop

    pop hl

    ; Load x-coordinate into register b
    ld a,h
    rrca
    rrca
    rrca
    rrca
    and 0x0f
    add a,8
    ld d,a

    ; Load y-coordinate into register c
    ld a,h
    and 0x0f
    add a,4
    ld e,a

    ld h,0x81

    call draw_char

    jp update_graphics

end start
